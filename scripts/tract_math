#!/usr/bin/env python
import os
import sys
from warnings import warn
from itertools import takewhile

from argparse import ArgumentParser, FileType, REMAINDER


def function_help_decorator(help_text):
    def internal_decorator(func):
        func.help_text = help_text
        return func
    return internal_decorator


def main():
    functions_list = dict((
        (f[0], f[1]) for f in globals().items() if hasattr(f[1], 'help_text')
    ))

    usage = r"""
    usage: %(prog)s <tract1.vtk> ... <tractN.vtk> operation <operation parameter1> ... <operation parameterN> <output_tract.vtk>

    Available operations:
    """

    function_list_names = functions_list.keys()
    function_list_names.sort()
    for f in function_list_names:
        usage += '\t%s %s\n' % (f, functions_list[f].help_text)

    n_tracts = 0
    for _ in takewhile(lambda x: x not in function_list_names, sys.argv[1:]):
        n_tracts += 1
    if n_tracts == len(sys.argv[1:]):
        n_tracts -= 1

    parser = ArgumentParser(usage=usage)
    parser.add_argument('tractographies', nargs=n_tracts, help='tractography files', type=FileType('r'))
    parser.add_argument('operation', type=str, choices=function_list_names,
                        help="operation to use")
    parser.add_argument('operation_parameters', type=str, nargs=REMAINDER,
                        help="operation to use")

    args = parser.parse_args()
    global tr, vtkInterface, numpy, nibabel
    from tract_querier.tractography import tractography as tr
    from tract_querier.tractography import vtkInterface
    import numpy
    import nibabel

    tractography = [tr.tractography_from_vtk_files(f.name)
        for f in args.tractographies
    ]
    if len(tractography) == 1:
        tractography = tractography[0]
    if  args.operation in functions_list:
        try:
            functions_list[args.operation](tractography, *args.operation_parameters)
        except TypeError as e:
            parser.error("Wrong number of parameters for the operation")
    else:
        parser.error("Operation not found")


@function_help_decorator(': counts the number of tracts')
def count(tractography):
    print len(tractography.getFibersToProcess())


@function_help_decorator(': print the names of scalar data associated with each tract')
def scalars(tractography):
    for k in tractography.getOriginalData().keys():
        print k, ' '


@function_help_decorator(': calculates mean and std of fiber length')
def length_mean_std(tractography):
    lengths = numpy.empty(len(tractography.getFibersToProcess()))

    for i, tract in enumerate(tractography.getFibersToProcess()):
        lengths[i] = tract_length(tract)

    mean = lengths.mean()
    std = lengths.std()

    print mean, std
    return mean, std

def tract_length(tract):
    d2 = numpy.sqrt((numpy.diff(tract, axis=0) ** 2).sum(1))
    return d2.sum()


@function_help_decorator('<volume unit>: calculates the volume of a tract based on voxel occupancy of a certain voxel volume')
def tract_volume(tractography, resolution):
    resolution = float(resolution)
    all_points = numpy.vstack(tractography.getFibersToProcess())

    all_points /= resolution
    all_points = (all_points - .5).round(0).astype(int)
    num_voxels = len(set((tuple(point) for point in all_points)))

    print num_voxels * (resolution ** 3)
    return num_voxels * (resolution ** 3)


@function_help_decorator('<scalar>: calculates mean and std of a scalar quantity for each tract')
def scalar_tract_mean_std(tractography, scalar):
    try:
        tracts = tractography.getOriginalFibersData()[scalar]
        means = []
        stds = []
        for i, t in enumerate(tracts):
            means.append(t.mean().squeeze())
            stds.append(t.std().squeeze())
            print means[-1], stds[-1]

        return means, stds

    except KeyError:
        raise ValueError("Tractography does not contain this scalar data")


@function_help_decorator('<scalar>: calculates median of a scalar quantity for each tract')
def scalar_tract_median(tractography, scalar):
    try:
        tracts = tractography.getOriginalFibersData()[scalar]
        medians = []
        for i, t in enumerate(tracts):
            medians.append(numpy.median(t).squeeze())
            print medians[-1]

        return medians

    except KeyError:
        raise ValueError("Tractography does not contain this scalar data")


@function_help_decorator('<scalar>: calculates mean and std of a scalar quantity over tracts')
def scalar_mean_std(tractography, scalar):
    try:
        scalars = tractography.getOriginalData()[scalar]
        all_scalars = numpy.vstack(scalars)
        mean = all_scalars.mean(0)
        std = all_scalars.std(0)

        print mean.squeeze(), std.squeeze()
        return mean, std

    except KeyError:
        raise ValueError("Tractography does not contain this scalar data")


@function_help_decorator('<scalar>: calculates median of a scalar quantity over tracts')
def scalar_median(tractography, scalar):
    try:
        scalars = tractography.getOriginalData()[scalar]
        all_scalars = numpy.vstack(scalars)
        median = numpy.median(all_scalars)

        print median
        return median

    except KeyError:
        raise ValueError("Tractography does not contain this scalar data")


@function_help_decorator(': Minimum and maximum distance between two consecutive points')
def tract_point_distance_min_max(tractography):
    dist_min = numpy.empty(len(tractography.getFibersToProcess()))
    dist_max = numpy.empty(len(tractography.getFibersToProcess()))
    for i, tract in enumerate(tractography.getFibersToProcess()):
        dist = tract_length(tract)
        dist_min[i] = dist.min()
        dist_max[i] = dist.max()
    print dist_min.min(), dist_max.max()


@function_help_decorator('<points per tract> <tractography_file_output>: subsamples tracts to a maximum number of points')
def tract_subsample(tractography, points_per_tract, tractography_file_output):
    tractography.subsampleFibers(int(points_per_tract))
    vtkInterface.writeLinesToVtkPolyData(
        tractography_file_output, tractography.getFibersToProcess(),  tractography.getFibersDataToProcess()
    )


@function_help_decorator('<mm per tract> <tractography_file_output>: subsamples tracts to a maximum number of points')
def tract_remove_short_fibers(tractography, min_tract_length, tractography_file_output):

    min_tract_length = float(min_tract_length)

    tracts = tractography.getFibersToProcess()
    data = tractography.getFibersDataToProcess()

    tract_ix_to_keep = [
        i for i, tract in enumerate(tractography.getFibersToProcess())
        if tract_length(tract) > min_tract_length
    ]

    selected_tracts = [tracts[i] for i in tract_ix_to_keep]

    selected_data = dict()
    for key, item in data.items():
        if len(item) == len(tracts):
            selected_data_items = [item[i] for i in tract_ix_to_keep]
            selected_data[key] = selected_data_items
        else:
            selected_data[key] = item


    vtkInterface.writeLinesToVtkPolyData(
        tractography_file_output, selected_tracts, selected_data)


@function_help_decorator('<thickness> <subsampling> <tractography1.vtk> ... <tractographyN.vtk>: measures the volume overlap of one tract with others')
def tract_tensor_similarity(tractography, thickness, subsampling, *tracts):
    from tract_querier.tensor_covariance import fiberSegments
    thickness = float(thickness)
    subsampling = int(subsampling)

    tractography.subsampleFibers(subsampling)
    t_gp = [fiberSegments.FiberSegmentGaussianProcess(t, thickness) for t in tractography.getFibersToProcess()]
    bundle = fiberSegments.FiberBundleSegmentGaussianProcess(t_gp)
    bundle_norm = bundle * bundle
    for tract in tracts:
        tract = tr.tractography_from_vtk_files(tract)
        tract.subsampleFibers(subsampling)
        t_gp1 = [fiberSegments.FiberSegmentGaussianProcess(t, thickness) for t in tract.getFibersToProcess()]
        bundle1 = fiberSegments.FiberBundleSegmentGaussianProcess(t_gp1)
        print (bundle * bundle1) / numpy.sqrt(bundle_norm * (bundle1 * bundle1))


@function_help_decorator('<image> <quantity_name> <tractography_file_output>: maps the values of an image to the tract points')
def tract_map_image(tractography, image, quantity_name, tractography_file_output):
    from os import path
    from scipy import ndimage

    image = nibabel.load(image)

    ijk_points = tract_in_ijk(image, tractography)
    image_data = image.get_data()

    if image_data.ndim > 3:
        output_name, ext = path.splitext(tractography_file_output)
        output_name = output_name + '_%04d' + ext
        for i, image in enumerate(image_data):
            new_scalar_data = ndimage.map_coordinates(
                image.T, ijk_points.T
            )[:, None]
            tractography.getOriginalFibersData()[quantity_name] = new_scalar_data
            vtkInterface.writeLinesToVtkPolyData(output_name % i, tractography.getOriginalFibers(),  tractography.getOriginalFibersData())
    else:
        new_scalar_data = ndimage.map_coordinates(
            image_data.T, ijk_points.T
        )[:, None]
        tractography.getOriginalFibersData()[quantity_name] = new_scalar_data
        vtkInterface.writeLinesToVtkPolyData(
            tractography_file_output, tractography.getOriginalFibers(),  tractography.getOriginalFibersData()
        )


@function_help_decorator('<image> <mask_out>: calculates the mask image from a tract on the space of the given image')
def tract_generate_mask(tractography, image, image_out):
    image = nibabel.load(image)

    mask = tract_mask(image, tractography)

    nibabel.save(nibabel.spatialimages.SpatialImage(mask, image.get_affine()), image_out)


@function_help_decorator('<image> <image_out>: calculates the probabilistic tract image for these tracts')
def tract_generate_probability_map(tractographies, image, image_out):
    image = nibabel.load(image)

    if isinstance(tractographies, tr.tractography):
        tractographies = [tractographies]

    prob_map = tract_mask(image, tractographies[0]).astype(float)

    for tract in tractographies[1:]:
        prob_map += tract_mask(image, tract)

    prob_map /= len(tractographies)


    nibabel.save(nibabel.spatialimages.SpatialImage(prob_map, image.get_affine()), image_out)


@function_help_decorator('<tractography_out>: takes the union of all tractographies')
def tract_merge(tractographies, tractography_file_output):
    all_tracts = []
    all_data = {}
    keys = [set(t.getFibersDataToProcess().keys()) for t in tractographies]
    common_keys = keys[0].intersection(*keys[1:])
    for tract in tractographies:
        tracts = tract.getFibersToProcess()
        all_tracts += tract.getFibersToProcess()
        data = tract.getFibersDataToProcess()
        for k in common_keys:
            if len(data[k]) == len(tracts):
                if k not in all_data:
                    all_data[k] = []
                all_data[k] += data[k]
            else:
                all_data[k] = data[k]

    vtkInterface.writeLinesToVtkPolyData(
        tractography_file_output,
        all_tracts, all_data
    )


@function_help_decorator('<volume unit> <tract1.vtk> ... <tractN.vtk>: calculates the kappa value of the first tract with the rest in the space of the reference image')
def tract_kappa(tractography, resolution, *other_tracts):
    resolution = float(resolution)

    voxels = voxelized_tract(tractography, resolution)

    for tract in other_tracts:
        voxels1 = voxelized_tract(tr.tractography_from_vtk_files(tract), resolution)

        all_voxels = numpy.array(list(voxels.union(voxels1)))
        N = (all_voxels.max(0) - all_voxels.min(0)).prod()
        pp = len(voxels.intersection(voxels1)) * 1.
        pn = len(voxels.difference(voxels1)) * 1.
        np = len(voxels1.difference(voxels)) * 1.
        nn = N - pp - pn - np
        observed_agreement = (pp + nn) / N
        chance_agreement = ((pp + pn) * (pp + np) + (nn + np) * (nn + pn)) / (N * N)

        k = (observed_agreement - chance_agreement) / (1 - chance_agreement)

        print k


@function_help_decorator('<volume unit> <tract1.vtk> ... <tractN.vtk>: calculates the dice coefficient of the first tract with the rest in the space of the reference image')
def tract_dice(tractography, resolution, *other_tracts):
    resolution = float(resolution)

    voxels = voxelized_tract(tractography, resolution)

    for tract in other_tracts:
        voxels1 = voxelized_tract(tr.tractography_from_vtk_files(tract), resolution)
        print 2 * len(voxels.intersection(voxels1)) * 1. / (len(voxels) + len(voxels1))


def voxelized_tract(tractography, resolution):
    from itertools import izip
    all_points = numpy.vstack(tractography.getFibersToProcess())
    all_points /= resolution
    all_points = (all_points - .5).round(0).astype(int)
    return set(izip(*(all_points.T)))



@function_help_decorator('<var> <tract_out>: smoothes the tract by convolving with a sliding window')
def tract_smooth(tractography, var, tractography_file_output):
    from sklearn.neighbors import BallTree

    var = float(var)
    std = var ** 2

    points = tractography.getOriginalFibers()

    all_points = numpy.vstack(points)
    bt = BallTree(all_points)
    N = len(all_points) / 3
    norm_term = 1. / (numpy.sqrt(2 * numpy.pi) * std)
    I = numpy.eye(3)[None, ...]
    for i, tract in enumerate(tractography.getOriginalFibers()):
        #all_points = numpy.vstack(points[:i] + points[i + 1:])
        #bt = BallTree(all_points)

        diff = numpy.diff(tract, axis=0)
        diff = numpy.vstack((diff, diff[-1]))
        lengths = numpy.sqrt((diff ** 2).sum(1))
        #cum_lengths = numpy.cumsum(lengths)

        diff_norm = diff / lengths[:, None]
        tangent_lines = diff_norm[:, None, :] * diff_norm[:, :, None]
        normal_planes = I - tangent_lines
#        weight_matrices = normal_planes + 1e10 * tangent_lines

        N = max(len(d) for d in bt.query_radius(tract, var * 3))

        close_point_distances, close_point_indices = bt.query(
            tract, N
        )


        close_points = all_points[close_point_indices]
        difference_vectors = close_points - tract[:, None, :]
        projected_vectors = (
            normal_planes[:, None, :] *
            difference_vectors[..., None]
        ).sum(-2)
        projected_points = projected_vectors + tract[:, None, :]
        #projected_distances2 = (projected_vectors**2).sum(-1)
        #projected_weights = numpy.exp(- .5 * projected_distances2 / std)
        #projected_weights /= projected_weights.sum(-1)[:, None]

        weights = numpy.exp(
            -.5 * close_point_distances ** 2 / std
        )[..., None]
        weights /= weights.sum(-2)[..., None]

        #tract += (weights * projected_vectors).sum(-2)


#        weighted_distances = (
#            weight_matrices[:, None, :] *
#            difference_vectors[..., None]
#        ).sum(-2)
#        weighted_distances *= difference_vectors
#        weighted_distances = weighted_distances.sum(-1) ** .5
        #weighted_points = (projected_points * weights).sum(1)

        weighted_points = (projected_points * weights).sum(1)

        #import ipdb
        #ipdb.set_trace()
        tract[:] = weighted_points
        #tract /= norm_term

    vtkInterface.writeLinesToVtkPolyData(
        tractography_file_output,
        tractography.getOriginalFibers(),  tractography.getOriginalFibersData()
    )


def tract_mask(image, tractography):
    ijk_points = tract_in_ijk(image, tractography)
    image_data = image.get_data()

    ijk_clipped = ijk_points.clip(
        (0, 0, 0), image_data.shape
    ).astype(int)

    mask = numpy.empty_like(image_data, dtype=float)
    mask[tuple(ijk_clipped.T)] = 1
    return mask


def tract_in_ijk(image, tractography):
    ras_points = numpy.vstack(tractography.getFibersToProcess())
    ijk_points = numpy.dot(numpy.linalg.inv(image.get_affine()), numpy.hstack((
          ras_points,
          numpy.ones((len(ras_points), 1))
                  )).T).T[:, :-1]
    return ijk_points


if __name__ == "__main__":
    main()
    sys.exit()
