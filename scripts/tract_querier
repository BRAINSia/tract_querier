#!/usr/bin/env python -O
from optparse import OptionParser
import os


def main():
    parser = OptionParser(
        version=0.1,
        usage="usage: %prog -t tractography_file -a atlas_file "
        "-q queries -o result_prefix"
    )
    parser.add_option("-t", "--tractography", dest="tractography_file_name",
                    help="name of the tractography file")
    parser.add_option("-a", "--atlas", dest="atlas_file_name",
                    help="name of the atlas file")
    parser.add_option("-q", "--queries", dest="queries_string",
                    help="query to run")
    parser.add_option('-o', "--output", dest="output_file_name",
                    help="clustering output file prefix")
    parser.add_option(
        '--threshold', dest='threshold', default=2,
        help="Minimum percentage of the fiber to be "
        "considered inside of the label default %default %"
    )
    parser.add_option('--length_threshold', dest='length_threshold', default=0,
        help="Minimum length of the fiber to be considered (in mm) "
                      "default %default %"
    )
    parser.add_option('--zscore_threshold', dest='zscore_threshold', default=0,
                    help="Outlier rejection threshold default %default %")
    parser.add_option('--query_selection', dest='query_selection', default='',
                    help="Query selection %default %")
    parser.add_option('--interactive', dest='interactive',
                      default=False, action="store_true",
                      help="Interactive prompt"
                     )

    (options, args) = parser.parse_args()

    if not options.tractography_file_name or\
       not options.atlas_file_name or\
       not options.queries_string or\
       not options.output_file_name:
        parser.error("incorrect number of arguments")

    options.threshold = float(options.threshold)
    options.length_threshold = float(options.length_threshold)

    global np
    global tract_querier
    import numpy as np
    import nibabel

    global tract_querier
    import tract_querier
    from tractographyGP import tractography

    print "Loading files"

    try:
        if os.path.exists(options.queries_string):
            query_file_body = tract_querier.queries_preprocess(
                file(options.queries_string).read(),
                filename=options.queries_string
            )
        else:
            query_file_body = tract_querier.queries_preprocess(
                options.queries_string,
                filename=options.queries_string
            )

        tract_querier.queries_syntax_check(query_file_body)
    except tract_querier.TractQuerierSyntaxError, e:
        parser.error(e.value)

    labels_nii = nibabel.load(options.atlas_file_name)
    img = labels_nii.get_data()

    tr = tractography.tractography_from_vtk_files(
        options.tractography_file_name
    )

    print "Calculating labels and crossings"
    affine_ras_2_ijk = np.linalg.inv(labels_nii.get_affine())
    fibers = tr.getFibersToProcess()

    fibers_labels, labels_fibers = tract_querier.compute_fiber_label_indices(
        affine_ras_2_ijk, img, fibers,
        options.length_threshold, options.threshold
    )

    if not options.interactive:
        print "Computing queries"
        evaluated_queries = tract_querier.eval_queries(
            labels_fibers,
            fibers_labels,
            query_file_body
        )

        query_names = evaluated_queries.keys()
        if options.query_selection != '':
            selected_queries = set(options.query_selection.lower().split(','))
            query_names = list(set(query_names) & set(selected_queries))

        query_names.sort()

        for query_name in query_names:
            save_query(query_name, tr, options, evaluated_queries)
    else:
        query_save = (
            lambda query_name, query_result:
                save_query(query_name, tr, options, {query_name: query_result})
        )

        interactive_shell = tract_querier.TractQuerierCmd(
            fibers_labels, labels_fibers,
            initial_body=file(options.queries_string).read(),
            save_query_callback=query_save
        )

        interactive_shell.cmdloop()


def save_query(query_name, tractography, options, evaluated_queries):
    fiber_numbers = evaluated_queries[query_name]
    print "\tQuery %s: %.6d" % (query_name, len(fiber_numbers))
    if fiber_numbers:
        save_tractography_file(
            options.output_file_name + "_" + query_name + '.vtk',
            tractography,
            fiber_numbers,
            zscore_threshold=float(options.zscore_threshold)
        )


def save_tractography_file(
    filename, tractography, fiber_numbers,
    zscore_threshold=3
):
    from tractographyGP import vtkInterface
    from itertools import izip

    fiber_numbers = list(fiber_numbers)

    original_fibers = tractography.getOriginalFibers()

    fibers_to_analyze_for_outlier_rejection = [
        original_fibers[i] for i in fiber_numbers
    ]

    if zscore_threshold > 0:
        fiber_numbers_to_save, zscore_per_fiber = (
            tract_querier.z_score_outlier_rejection(
                fibers_to_analyze_for_outlier_rejection,
                z_score_reject=zscore_threshold
            )
        )
        zscore_per_fiber.sort()
        print '\t', len(fiber_numbers_to_save)
        fiber_numbers = [fiber_numbers[i] for i in fiber_numbers_to_save]

    fibers_to_save = [original_fibers[i] for i in fiber_numbers]

    if len(fibers_to_save) == 0:
        return

    fibers_data_to_save = {}
    for key, data in tractography.getOriginalFibersData().items():
        fibers_data_to_save[key] = [data[f] for f in fiber_numbers]

    if (
        'ActiveTensors' not in fibers_data_to_save and
        'Tensors_' in fibers_data_to_save
    ):
        fibers_data_to_save['ActiveTensors'] = 'Tensors_'
    if (
        'ActiveVectors' not in fibers_data_to_save and
        'Vectors_' in fibers_data_to_save
    ):
        fibers_data_to_save['ActiveVectors'] = 'Vectors_'

    if zscore_threshold > 0:
        z_scores_fiber_data = [
            np.repeat(z_score, len(fiber))[:, None]
            for z_score, fiber in izip(zscore_per_fiber, fibers_to_save)
        ]
        fibers_data_to_save['z_score'] = z_scores_fiber_data

    vtkInterface.writeLinesToVtkPolyData(
        filename,
        fibers_to_save,
        fibers_data_to_save
    )


if __name__ == "__main__":
    main()
