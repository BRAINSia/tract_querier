#!/usr/bin/env python
from optparse import OptionParser
import os
import sys

def main():
    parser = OptionParser(
        version=0.1,
        usage="usage: %prog -t tractography_file -a atlas_file "
        "-q queries -o result_prefix"
    )
    parser.add_option("-t", "--tractography", dest="tractography_file_name",
                    help="name of the tractography file")
    parser.add_option("-a", "--atlas", dest="atlas_file_name",
                    help="name of the atlas file")
    parser.add_option("-q", "--queries", dest="queries_string",
                    help="query to run")
    parser.add_option('-o', "--output", dest="output_file_name",
                    help="clustering output file prefix")
    parser.add_option('-I',  dest="include",
                    help="folders to include query files")
    parser.add_option(
        '--threshold', dest='threshold', default=2,
        help="Minimum percentage of the fiber to be "
        "considered inside of the label default %default %"
    )
    parser.add_option('--length_threshold', dest='length_threshold', default=0,
        help="Minimum length of the fiber to be considered (in mm) "
                      "default %default %"
    )
    parser.add_option('--zscore_threshold', dest='zscore_threshold', default=0,
                    help="Outlier rejection threshold default %default %")
    parser.add_option('--query_selection', dest='query_selection', default='',
                    help="Query selection %default %")
    parser.add_option('--interactive', dest='interactive',
                      default=False, action="store_true",
                      help="Interactive prompt"
                     )
    parser.add_option(
        '--bounding_box_affine_transform', dest='bounding_box_affine_transform',
        help="Bounding box to apply to the image affine transform and tracts "
        "to put both in AC-PC coordinate space"
    )


    (options, args) = parser.parse_args()

    if not options.tractography_file_name or\
       not options.atlas_file_name or\
       not options.queries_string or\
       not options.output_file_name:
        parser.error("incorrect number of arguments")

    options.threshold = float(options.threshold)
    options.length_threshold = float(options.length_threshold)

    global np
    global tract_querier
    import numpy as np
    import nibabel

    global tract_querier
    import tract_querier
    from tract_querier.tractography import tractography

    if options.bounding_box_affine_transform:
        bounding_box_affine_transform = np.fromstring(
            options.bounding_box_affine_transform, sep=','
        ).reshape(4, 4)
        print "RAS transform:"
        print bounding_box_affine_transform
    else:
        bounding_box_affine_transform = np.eye(4)


    print "Loading files"
    if options.include:
        folders = options.include.split(':')
    else:
        folders = []

    default_folder = os.path.join(sys.prefix, 'tract_querier', 'queries')
    folders = [os.getcwd()] + folders + [default_folder]
    for folder in folders:
        if not (os.path.exists(folder) and os.path.isdir(folder)):
            parser.error("Error in include folder %s" % folder)

    try:
        if os.path.exists(options.queries_string):
            query_script = file(options.queries_string).read()
            query_filename = options.queries_string
        else:
            found = False
            for folder in folders:
                file_ = os.path.join(folder, options.queries_string)
                if os.path.exists(file_):
                    found = True
                    break
            if found:
                query_script = file(file_).read()
                query_filename = file_
            else:
                query_script = options.queries_string
                query_filename = '<script>'

        query_file_body = tract_querier.queries_preprocess(
            query_script,
            filename=query_filename,
            include_folders=folders
        )



        tract_querier.queries_syntax_check(query_file_body)
    except tract_querier.TractQuerierSyntaxError, e:
        parser.error(e.value)

    labels_nii = nibabel.load(options.atlas_file_name)
    img = labels_nii.get_data()

    tr = tractography.tractography_from_vtk_files(
        options.tractography_file_name
    )

    print "Calculating labels and crossings"
    affine_ijk_2_ras = labels_nii.get_affine()
    affine_ras_2_ijk = np.linalg.inv(affine_ijk_2_ras)
    fibers = tr.getFibersToProcess()

    crossing_fibers_labels, crossing_labels_fibers, ending_fibers_labels, ending_labels_fibers =\
            tract_querier.compute_fiber_label_indices(
                affine_ras_2_ijk, img, fibers,
                options.length_threshold, options.threshold
            )

    fiber_bounding_boxes = tract_querier.compute_fiber_bounding_boxes(fibers, bounding_box_affine_transform)
    label_bounding_boxes = tract_querier.compute_label_bounding_boxes(img, np.dot(bounding_box_affine_transform, affine_ijk_2_ras))

    if not options.interactive:
        print "Computing queries"
        evaluated_queries = tract_querier.eval_queries(
            query_file_body,
            crossing_labels_fibers,
            crossing_fibers_labels,
            ending_labels_fibers,
            ending_fibers_labels,
            fiber_bounding_boxes,
            label_bounding_boxes,
        )

        query_names = evaluated_queries.keys()
        if options.query_selection != '':
            selected_queries = set(options.query_selection.lower().split(','))
            query_names = list(set(query_names) & set(selected_queries))

        query_names.sort()

        for query_name in query_names:
            save_query(query_name, tr, options, evaluated_queries)
    else:
        query_save = (
            lambda query_name, query_result:
                save_query(query_name, tr, options, {query_name: query_result})
        )

        interactive_shell = tract_querier.TractQuerierCmd(
            crossing_fibers_labels, crossing_labels_fibers,
            ending_fibers_labels, ending_labels_fibers,
            fiber_bounding_boxes, label_bounding_boxes,
            initial_body=query_script,
            save_query_callback=query_save,
            include_folders=folders
        )

        interactive_shell.cmdloop()


def save_query(query_name, tractography, options, evaluated_queries):
    fiber_numbers = evaluated_queries[query_name]
    print "\tQuery %s: %.6d" % (query_name, len(fiber_numbers))
    if fiber_numbers:
        save_tractography_file(
            options.output_file_name + "_" + query_name + '.vtk',
            tractography,
            fiber_numbers,
            zscore_threshold=float(options.zscore_threshold)
        )


def save_tractography_file(
    filename, tractography, fiber_numbers,
    zscore_threshold=3
):
    from tract_querier.tractography import vtkInterface
    from itertools import izip

    fiber_numbers = list(fiber_numbers)

    original_fibers = tractography.getOriginalFibers()

    fibers_to_analyze_for_outlier_rejection = [
        original_fibers[i] for i in fiber_numbers
    ]

    if zscore_threshold > 0:
        fiber_numbers_to_save, zscore_per_fiber = (
            tract_querier.z_score_outlier_rejection(
                fibers_to_analyze_for_outlier_rejection,
                z_score_reject=zscore_threshold
            )
        )
        zscore_per_fiber.sort()
        print '\t', len(fiber_numbers_to_save)
        fiber_numbers = [fiber_numbers[i] for i in fiber_numbers_to_save]

    fibers_to_save = [original_fibers[i] for i in fiber_numbers]

    if len(fibers_to_save) == 0:
        return

    fibers_data_to_save = {}
    for key, data in tractography.getOriginalFibersData().items():
        fibers_data_to_save[key] = [data[f] for f in fiber_numbers]

    if (
        'ActiveTensors' not in fibers_data_to_save and
        'Tensors_' in fibers_data_to_save
    ):
        fibers_data_to_save['ActiveTensors'] = 'Tensors_'
    if (
        'ActiveVectors' not in fibers_data_to_save and
        'Vectors_' in fibers_data_to_save
    ):
        fibers_data_to_save['ActiveVectors'] = 'Vectors_'

    if zscore_threshold > 0:
        z_scores_fiber_data = [
            np.repeat(z_score, len(fiber))[:, None]
            for z_score, fiber in izip(zscore_per_fiber, fibers_to_save)
        ]
        fibers_data_to_save['z_score'] = z_scores_fiber_data

    vtkInterface.writeLinesToVtkPolyData(
        filename,
        fibers_to_save,
        fibers_data_to_save
    )


if __name__ == "__main__":
    main()
    sys.exit()
